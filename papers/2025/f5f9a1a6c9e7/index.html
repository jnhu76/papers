<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Parallel kd-tree with Batch Updates</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body { 
      font-family: 'Inter', sans-serif; 
      scroll-behavior: smooth;
    }
    .mobile-optimized { 
      margin-bottom: 2rem !important; 
    }
    @media (max-width: 768px) {
      .content-section { 
        padding: 1rem; 
        margin-bottom: 1.5rem;
      }
      .technical-details {
        margin: 1rem 0;
      }
    }
    .hide-scrollbar {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .hide-scrollbar::-webkit-scrollbar {
      display: none;
    }
    .nav-item {
      @apply px-4 py-2 rounded-lg transition-colors duration-200 text-gray-600 hover:text-blue-600 hover:bg-blue-50;
    }
    .nav-item.active {
      @apply text-blue-600 bg-blue-100;
    }
  </style>
</head>
<body class="bg-gradient-to-br from-blue-400 via-purple-500 to-pink-400 min-h-screen">
  <!-- 导航系统 -->
  <nav class="nav-scroll bg-white/90 backdrop-blur-sm sticky top-0 z-50 border-b border-gray-200">
    <div class="container mx-auto px-4 py-3">
      <div class="flex overflow-x-auto space-x-6 hide-scrollbar">
        <a href="#abstract" class="nav-item whitespace-nowrap">摘要</a>
        <a href="#background-motivation" class="nav-item whitespace-nowrap">背景与动机</a>
        <a href="#challenges" class="nav-item whitespace-nowrap">问题与挑战</a>
        <a href="#design-implementation" class="nav-item whitespace-nowrap">设计与实现</a>
        <a href="#evaluation" class="nav-item whitespace-nowrap">测试与评估</a>
        <a href="#conclusion" class="nav-item whitespace-nowrap">结论</a>
      </div>
    </div>
  </nav>

  <div class="container mx-auto px-4 py-8">
    <div class="bg-white/95 backdrop-blur-sm rounded-xl shadow-lg p-6">
      <!-- 论文标题和元数据 -->
      <div class="mb-12 md:mb-16">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-800 mb-6 text-center md:text-left">
          Parallel kd-tree with Batch Updates
        </h1>
        
        <div class="bg-gradient-to-r from-blue-50 to-purple-50 border-l-4 border-blue-500 p-6 rounded-r-lg">
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-gray-700">
            <div class="space-y-3">
              <div>
                <strong class="text-blue-700 block mb-1">作者信息</strong>
                <div class="text-lg">Ziyang Men, Zheqi Shen, Yan Gu, Yihan Sun</div>
                <div class="text-sm text-gray-600 mt-1">UC Riverside</div>
              </div>
              <div>
                <strong class="text-blue-700 block mb-1">发表信息</strong>
                <div>International Conference on Management of Data (SIGMOD), 2025</div>
              </div>
            </div>
            <div class="space-y-3">
              <div>
                <strong class="text-blue-700 block mb-1">代码仓库</strong>
                <div class="font-mono text-sm bg-white px-3 py-2 rounded border">https://github.com/ucrparlay/Pkd-tree</div>
              </div>
              <div>
                <strong class="text-blue-700 block mb-1">关键词</strong>
                <div class="flex flex-wrap gap-2 mt-1">
                  <span class="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm">kd-tree</span>
                  <span class="bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm">并行算法</span>
                  <span class="bg-purple-100 text-purple-800 px-3 py-1 rounded-full text-sm">批量更新</span>
                  <span class="bg-yellow-100 text-yellow-800 px-3 py-1 rounded-full text-sm">缓存优化</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- 核心贡献 -->
      <div class="bg-gradient-to-r from-green-50 to-blue-50 border-l-4 border-green-500 p-6 rounded-r-lg mb-12">
        <h4 class="font-bold text-green-700 mb-4 flex items-center text-xl">
          <i class="fas fa-trophy mr-2"></i>核心贡献
        </h4>
        <ul class="list-disc list-inside space-y-2 text-gray-700">
          <li><strong>并行构建算法</strong>：首个在work、span和cache复杂度上同时优化的kd-tree构建算法</li>
          <li><strong>批量更新机制</strong>：基于重构的更新算法，保证树的权重平衡</li>
          <li><strong>理论保证</strong>：证明了算法在work、span和cache复杂度上的强理论界限</li>
          <li><strong>高效实现</strong>：通过精心工程化实现了高度优化的Pkd-tree实现</li>
        </ul>
      </div>
      
      <!-- 摘要 -->
      <section id="abstract" class="content-section mobile-optimized mb-12 md:mb-16">
        <h2 class="text-2xl md:text-3xl font-bold text-gray-800 mb-6 md:mb-8 flex items-center">
          <i class="fas fa-file-alt mr-3 text-blue-500"></i>
          摘要
        </h2>
        
        <div class="prose max-w-none text-gray-700">
          <p class="mb-4">
            kd-tree是管理多维数据最广泛使用的数据结构之一。由于数据量的不断增长，在kd-tree中考虑并行性变得至关重要。然而，作者观察到现有并行kd-tree实现在构建和更新方面都存在挑战。
          </p>
          <p class="mb-4">
            本文的目标是通过支持高并行性和缓存效率来开发高效的内存kd-tree。作者提出了Pkd-tree（并行kd-tree），这是一种在理论和实践中都高效的并行kd-tree。Pkd-tree支持并行树构建、批量更新（插入和删除）以及各种查询，包括k近邻搜索、范围查询和范围计数。
          </p>
          <p class="mb-4">
            作者证明了算法在work（顺序时间复杂度）、span（并行度）和cache复杂度方面具有强大的理论界限。关键技术包括：1）同时优化work、span和cache复杂度的高效构建算法；2）基于重构的更新算法，保证树的权重平衡。
          </p>
        </div>
      </section>
      
      <!-- 背景与动机 -->
      <section id="background-motivation" class="content-section mobile-optimized mb-12 md:mb-16">
        <h2 class="text-2xl md:text-3xl font-bold text-gray-800 mb-6 md:mb-8 flex items-center">
          <i class="fas fa-layer-group mr-3 text-blue-500"></i>
          背景与动机
        </h2>
        
        <div class="prose max-w-none text-gray-700">
          <p class="mb-4">
            kd-tree是管理多维数据最广泛使用的数据结构之一。kd-tree在D维空间中维护一组点，支持各种查询，如k近邻（k-NN）、正交范围计数和范围报告。与其他对应物相比，kd-tree具有独特的优势，如线性空间、简单算法、基于比较（因此对偏斜数据具有抵抗力）、扩展到合理大的维度（在D≈10以内高效）以及支持广泛的查询类型。
          </p>
          
          <div class="bg-yellow-50 border-l-4 border-yellow-500 p-4 rounded-r-lg mb-6">
            <h5 class="font-bold text-yellow-700 mb-2 flex items-center">
              <i class="fas fa-exclamation-circle mr-2"></i>性能挑战
            </h5>
            <p class="text-gray-700">
              例如，OpenStreetMap的北美地区包含12.9亿个节点，在单个核心上使用广泛采用的几何库CGAL为此数据集构建kd-tree需要超过2000秒。
            </p>
          </div>
          
          <p class="mb-4">
            作者观察到kd-tree的<strong>广泛使用</strong>与<strong>缺乏高性能并行实现</strong>之间存在显著差距，特别是在构建、更新和查询三个方面。现有的并行实现存在以下问题：
          </p>
          
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <div class="bg-red-50 p-4 rounded-lg border border-red-200">
              <h5 class="font-bold text-red-700 mb-2 flex items-center">
                <i class="fas fa-times-circle mr-2"></i>静态实现
              </h5>
              <p class="text-sm text-gray-700">一些现有并行实现是静态的，不支持更新。</p>
            </div>
            <div class="bg-red-50 p-4 rounded-lg border border-red-200">
              <h5 class="font-bold text-red-700 mb-2 flex items-center">
                <i class="fas fa-times-circle mr-2"></i>更新效率低
              </h5>
              <p class="text-sm text-gray-700">CGAL和BHL-tree不支持并行更新，即使是顺序更新也会完全重建树。</p>
            </div>
            <div class="bg-red-50 p-4 rounded-lg border border-red-200">
              <h5 class="font-bold text-red-700 mb-2 flex items-center">
                <i class="fas fa-times-circle mr-2"></i>查询性能差
              </h5>
              <p class="text-sm text-gray-700">Log-tree在k-NN查询上比BHL-tree或CGAL慢一个数量级。</p>
            </div>
            <div class="bg-red-50 p-4 rounded-lg border border-red-200">
              <h5 class="font-bold text-red-700 mb-2 flex items-center">
                <i class="fas fa-times-circle mr-2"></i>构建速度慢
              </h5>
              <p class="text-sm text-gray-700">现有kd-tree的构建时间比其他并行树结构（如二叉搜索树和四/八叉树）慢得多。</p>
            </div>
          </div>
        </div>
      </section>
      
      <!-- 问题与挑战 -->
      <section id="challenges" class="content-section mobile-optimized mb-12 md:mb-16">
        <h2 class="text-2xl md:text-3xl font-bold text-gray-800 mb-6 md:mb-8 flex items-center">
          <i class="fas fa-exclamation-triangle mr-3 text-blue-500"></i>
          问题与挑战
        </h2>
        
        <div class="prose max-w-none text-gray-700">
          <p class="mb-4">
            现有的并行kd-tree实现面临以下主要挑战：
          </p>
          
          <div class="space-y-6">
            <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
              <h4 class="font-bold text-gray-800 mb-3 flex items-center">
                <i class="fas fa-cube mr-2 text-blue-500"></i>
                构建效率挑战
              </h4>
              <p class="text-gray-700 mb-3">
                传统的并行kd-tree构建算法需要O(log n)轮数据移动，当输入大于缓存大小时缓存效率不高。这导致构建时间显著长于其他并行树结构。
              </p>
              <div class="bg-gray-50 p-3 rounded text-sm">
                <strong>技术问题：</strong> 标准的并行分区算法具有O(n log n) work和O(log² n) span，但缓存复杂度不理想。
              </div>
            </div>
            
            <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
              <h4 class="font-bold text-gray-800 mb-3 flex items-center">
                <i class="fas fa-sync-alt mr-2 text-green-500"></i>
                更新机制挑战
              </h4>
              <p class="text-gray-700 mb-3">
                kd-tree与其他经典树不同，不支持更新的重新平衡原语，如溢出/下溢（如B树）或旋转（如二叉搜索树）。现有的更新方法要么完全重建树（效率低），要么使用对数方法（查询性能差）。
              </p>
              <div class="bg-gray-50 p-3 rounded text-sm">
                <strong>技术问题：</strong> 对数方法维护O(log n)完美平衡的树，导致查询需要在所有树上执行并合并结果，显著增加了查询成本。
              </div>
            </div>
            
            <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
              <h4 class="font-bold text-gray-800 mb-3 flex items-center">
                <i class="fas fa-memory mr-2 text-purple-500"></i>
                缓存效率挑战
              </h4>
              <p class="text-gray-700 mb-3">
                现有实现在处理大规模数据时缓存效率不高，导致大量内存访问和性能下降。特别是在构建和更新过程中，数据移动成为主要瓶颈。
              </p>
              <div class="bg-gray-50 p-3 rounded text-sm">
                <strong>技术问题：</strong> 传统算法在递归构建过程中需要多次数据移动，无法充分利用缓存层次结构。
              </div>
            </div>
          </div>
        </div>
      </section>
      
      <!-- 设计与实现 -->
      <section id="design-implementation" class="content-section mobile-optimized mb-12 md:mb-16">
        <h2 class="text-2xl md:text-3xl font-bold text-gray-800 mb-6 md:mb-8 flex items-center">
          <i class="fas fa-cogs mr-3 text-blue-500"></i>
          设计与实现
        </h2>
        
        <div class="prose max-w-none text-gray-700">
          <p class="mb-6">
            Pkd-tree通过以下关键技术解决了上述挑战：
          </p>
          
          <!-- 并行构建算法 -->
          <div class="mb-8">
            <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
              <i class="fas fa-code-branch mr-2 text-blue-500"></i>
              并行构建算法
            </h3>
            
            <div class="bg-blue-50 p-4 rounded-lg border border-blue-200 mb-4">
              <h5 class="font-semibold text-blue-700 mb-3 flex items-center">
                <i class="fas fa-lightbulb mr-2"></i>核心思想
              </h5>
              <p class="text-gray-700">
                传统方法一次构建一层，需要O(log n)轮数据移动。Pkd-tree通过<strong>一次构建λ层</strong>来优化缓存效率，使用采样确定分割器，并通过一轮数据移动将所有点分区到对应的子树。
              </p>
            </div>
            
            <!-- 算法流程图 -->
            <details class="technical-details bg-gray-50 rounded-lg p-4 md:p-6 mb-8 mt-6">
              <summary class="cursor-pointer font-semibold text-lg md:text-xl text-gray-800 hover:text-blue-600 transition-colors py-2">
                <i class="fas fa-project-diagram mr-2"></i>算法流程：并行kd-tree构建
              </summary>
              
              <div class="mt-6 space-y-6">
                <!-- 原图展示部分 -->
                <div class="original-figure-container">
                  <div class="flex flex-col sm:flex-row sm:items-center justify-between mb-4 gap-2">
                    <h5 class="font-semibold text-gray-700 text-base md:text-lg">
                      <i class="fas fa-image mr-2 text-blue-500"></i>
                      原图 1: 构建算法示意图
                    </h5>
                    <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded self-start sm:self-auto">论文原图</span>
                  </div>
                  
                  <!-- 原图占位符 -->
                  <div class="image-placeholder bg-gradient-to-br from-gray-100 to-gray-200 p-6 md:p-8 rounded-lg text-center border-2 border-dashed border-gray-300">
                    <img src="./images/fig1.png" alt="论文图1: kd-tree构建算法示意图" class="max-w-full h-auto rounded-lg">
                  </div>
                  
                  <!-- 原图图注 -->
                  <div class="mt-4 text-sm text-gray-600 bg-gray-50 p-3 rounded border">
                    <strong>原图图注:</strong> 构建算法的示意图，展示采样、骨架构建和筛分过程。
                  </div>
                </div>
                
                <!-- 技术解释部分 -->
                <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                  <h5 class="font-semibold text-blue-700 mb-3 flex items-center text-base md:text-lg">
                    <i class="fas fa-info-circle mr-2"></i>技术解释：
                  </h5>
                  <ul class="list-disc list-inside space-y-2 text-sm md:text-base text-gray-700">
                    <li><strong>采样阶段:</strong> 从输入点中均匀采样2^λ·σ个点，构建包含前λ层的树骨架</li>
                    <li><strong>筛分阶段:</strong> 使用骨架将所有点分配到对应的桶中，通过一轮数据移动完成</li>
                    <li><strong>并行递归:</strong> 对每个桶并行递归构建子树，直到点数小于阈值</li>
                    <li><strong>参数选择:</strong> λ=Θ(log M)，σ=Θ(log n)，以平衡work、span和cache复杂度</li>
                  </ul>
                </div>
                
                <!-- 设计实现部分 -->
                <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                  <h5 class="font-semibold text-green-700 mb-3 flex items-center text-base md:text-lg">
                    <i class="fas fa-cogs mr-2"></i>设计实现：
                  </h5>
                  <div class="text-sm md:text-base text-gray-700 space-y-3">
                    <div>
                      <strong class="text-green-700">实现方法:</strong>
                      <p>算法将输入数组分成大小为l=2^λ的块，并行处理每个块，统计每个桶中的点数。然后计算列主序前缀和，得到每个点的偏移量，最后并行移动所有点到目标位置。</p>
                    </div>
                    <div>
                      <strong class="text-green-700">技术选择:</strong>
                      <p>选择λ=6作为默认值，平衡并行度和缓存效率。使用σ=32作为过采样率，确保树的平衡性。</p>
                    </div>
                    <div>
                      <strong class="text-green-700">优化策略:</strong>
                      <p>避免在递归调用中复制数组，通过交换指针节省内存访问。当输入大小小于1024时切换到顺序算法。</p>
                    </div>
                  </div>
                </div>
                
                <!-- 性能分析部分 -->
                <div class="bg-purple-50 p-4 rounded-lg border border-purple-200">
                  <h5 class="font-semibold text-purple-700 mb-3 flex items-center text-base md:text-lg">
                    <i class="fas fa-chart-line mr-2"></i>性能分析：
                  </h5>
                  <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm md:text-base">
                    <div>
                      <strong class="text-purple-700">理论保证:</strong>
                      <ul class="list-disc list-inside mt-1 text-gray-700">
                        <li>Work: O(n log n) - 最优</li>
                        <li>Span: O(log² n) - 高并行度</li>
                        <li>Cache: O((n/B)log_M n) - 最优</li>
                      </ul>
                    </div>
                    <div>
                      <strong class="text-purple-700">实际效果:</strong>
                      <ul class="list-disc list-inside mt-1 text-gray-700">
                        <li>构建速度提升: 8-12倍</li>
                        <li>缓存缺失减少: 6-12倍</li>
                        <li>并行扩展性: 良好</li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
            </details>
          </div>
          
          <!-- 批量更新算法 -->
          <div class="mb-8">
            <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
              <i class="fas fa-sync-alt mr-2 text-green-500"></i>
              批量更新算法
            </h3>
            
            <div class="bg-green-50 p-4 rounded-lg border border-green-200 mb-4">
              <h5 class="font-semibold text-green-700 mb-3 flex items-center">
                <i class="fas fa-lightbulb mr-2"></i>核心思想
              </h5>
              <p class="text-gray-700">
                使用<strong>权重平衡</strong>和<strong>惰性策略</strong>，允许兄弟子树大小相差最多α因子。当子树变得不平衡时，通过<strong>局部重构</strong>受影响子树来重新平衡。
              </p>
            </div>
            
            <!-- 更新算法流程图 -->
            <details class="technical-details bg-gray-50 rounded-lg p-4 md:p-6 mb-8 mt-6">
              <summary class="cursor-pointer font-semibold text-lg md:text-xl text-gray-800 hover:text-green-600 transition-colors py-2">
                <i class="fas fa-project-diagram mr-2"></i>算法流程：批量更新
              </summary>
              
              <div class="mt-6 space-y-6">
                <!-- 原图展示部分 -->
                <div class="original-figure-container">
                  <div class="flex flex-col sm:flex-row sm:items-center justify-between mb-4 gap-2">
                    <h5 class="font-semibold text-gray-700 text-base md:text-lg">
                      <i class="fas fa-image mr-2 text-blue-500"></i>
                      原图 2: 批量插入示意图
                    </h5>
                    <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded self-start sm:self-auto">论文原图</span>
                  </div>
                  
                  <!-- 原图占位符 -->
                  <div class="image-placeholder bg-gradient-to-br from-gray-100 to-gray-200 p-6 md:p-8 rounded-lg text-center border-2 border-dashed border-gray-300">
                    <img src="./images/fig2.png" alt="论文图2: 批量插入算法示意图" class="max-w-full h-auto rounded-lg">
                  </div>
                  
                  <!-- 原图图注 -->
                  <div class="mt-4 text-sm text-gray-600 bg-gray-50 p-3 rounded border">
                    <strong>原图图注:</strong> 批量插入算法的示意图，展示获取树骨架、筛分点、并行处理桶和重建不平衡子树的过程。
                  </div>
                </div>
                
                <!-- 技术解释部分 -->
                <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                  <h5 class="font-semibold text-blue-700 mb-3 flex items-center text-base md:text-lg">
                    <i class="fas fa-info-circle mr-2"></i>技术解释：
                  </h5>
                  <ul class="list-disc list-inside space-y-2 text-sm md:text-base text-gray-700">
                    <li><strong>权重平衡:</strong> 定义平衡参数α∈[0,0.5]，子树大小在(0.5±α)范围内视为平衡</li>
                    <li><strong>批量插入:</strong> 将新点筛分到对应子树，检测不平衡子树并重建</li>
                    <li><strong>批量删除:</strong> 两轮处理：首先筛分并识别不在树中的点，然后检测不平衡子树</li>
                    <li><strong>局部重构:</strong> 只重建不平衡的子树，而不是整个树</li>
                  </ul>
                </div>
                
                <!-- 设计实现部分 -->
                <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                  <h5 class="font-semibold text-green-700 mb-3 flex items-center text-base md:text-lg">
                    <i class="fas fa-cogs mr-2"></i>设计实现：
                  </h5>
                  <div class="text-sm md:text-base text-gray-700 space-y-3">
                    <div>
                      <strong class="text-green-700">实现方法:</strong>
                      <p>使用构建算法中的筛分过程作为子程序，将更新点分配到对应子树。计算更新后子树大小，检测不平衡子树并重建。</p>
                    </div>
                    <div>
                      <strong class="text-green-700">技术选择:</strong>
                      <p>选择α=0.3作为默认值，平衡更新性能和查询性能。使用σ=(δc log n)/α²确保低摊余成本。</p>
                    </div>
                    <div>
                      <strong class="text-green-700">优化策略:</strong>
                      <p>避免存储边界框以减少内存使用，在查询时动态计算子树空间。使用叶包装和重复点压缩进一步减少内存占用。</p>
                    </div>
                  </div>
                </div>
                
                <!-- 性能分析部分 -->
                <div class="bg-purple-50 p-4 rounded-lg border border-purple-200">
                  <h5 class="font-semibold text-purple-700 mb-3 flex items-center text-base md:text-lg">
                    <i class="fas fa-chart-line mr-2"></i>性能分析：
                  </h5>
                  <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm md:text-base">
                    <div>
                      <strong class="text-purple-700">理论保证:</strong>
                      <ul class="list-disc list-inside mt-1 text-gray-700">
                        <li>Span: O(log² n) - 高并行度</li>
                        <li>Work: O(log² n) 每点 - 摊余</li>
                        <li>Cache: O(log(n/m)+(log n log_M n)/B) 每点</li>
                      </ul>
                    </div>
                    <div>
                      <strong class="text-purple-700">实际效果:</strong>
                      <ul class="list-disc list-inside mt-1 text-gray-700">
                        <li>插入速度: 比Log-tree快17-40倍</li>
                        <li>删除速度: 比Log-tree快3-21倍</li>
                        <li>内存使用: 减少边界框存储</li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
            </details>
          </div>
          
          <!-- 查询算法 -->
          <div>
            <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
              <i class="fas fa-search mr-2 text-purple-500"></i>
              查询算法
            </h3>
            
            <div class="bg-purple-50 p-4 rounded-lg border border-purple-200 mb-4">
              <h5 class="font-semibold text-purple-700 mb-3 flex items-center">
                <i class="fas fa-lightbulb mr-2"></i>核心思想
              </h5>
              <p class="text-gray-700">
                由于Pkd-tree保持为单个kd-tree，经典kd-tree的相同查询算法可以直接在Pkd-tree上工作，无需任何修改。
              </p>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
              <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm text-center">
                <i class="fas fa-bullseye text-3xl text-blue-500 mb-3"></i>
                <h5 class="font-bold text-gray-800 mb-2">k-NN查询</h5>
                <p class="text-sm text-gray-600">使用标准深度优先搜索算法，根据查询点与分割器的距离剪枝分支</p>
              </div>
              <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm text-center">
                <i class="fas fa-vector-square text-3xl text-green-500 mb-3"></i>
                <h5 class="font-bold text-gray-800 mb-2">范围报告</h5>
                <p class="text-sm text-gray-600">递归遍历树，检查节点关联的子空间是否在查询框内，剪枝不交叉的分支</p>
              </div>
              <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm text-center">
                <i class="fas fa-calculator text-3xl text-purple-500 mb-3"></i>
                <h5 class="font-bold text-gray-800 mb-2">范围计数</h5>
                <p class="text-sm text-gray-600">报告查询范围内的点数，比范围报告更快，特别是输出规模大时</p>
              </div>
            </div>
          </div>
        </div>
      </section>
      
      <!-- 测试与评估 -->
      <section id="evaluation" class="content-section mobile-optimized mb-12 md:mb-16">
        <h2 class="text-2xl md:text-3xl font-bold text-gray-800 mb-6 md:mb-8 flex items-center">
          <i class="fas fa-chart-line mr-3 text-blue-500"></i>
          测试与评估
        </h2>
        
        <div class="prose max-w-none text-gray-700">
          <p class="mb-6">
            作者进行了广泛的实验来证明Pkd-tree的效率。测试包括合成数据集和真实世界数据集，涵盖构建、批量更新和各种查询。
          </p>
          
          <!-- 实验设置 -->
          <div class="mb-8">
            <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
              <i class="fas fa-cog mr-2 text-gray-500"></i>
              实验设置
            </h3>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
                <h5 class="font-bold text-gray-800 mb-3 flex items-center">
                  <i class="fas fa-desktop mr-2 text-blue-500"></i>
                  硬件环境
                </h5>
                <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                  <li><strong>CPU:</strong> 96核心（192超线程），四路Intel Xeon Gold 6252</li>
                  <li><strong>内存:</strong> 1.5 TB RAM</li>
                  <li><strong>实现:</strong> C++使用ParlayLib支持fork-join并行性</li>
                </ul>
              </div>
              
              <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
                <h5 class="font-bold text-gray-800 mb-3 flex items-center">
                  <i class="fas fa-database mr-2 text-green-500"></i>
                  数据集
                </h5>
                <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                  <li><strong>合成数据:</strong> Uniform（均匀分布）和Varden（偏斜分布）</li>
                  <li><strong>真实数据:</strong> OpenStreetMap, COSMOS, HT, CHEM, Household, GeoLife</li>
                  <li><strong>数据规模:</strong> 最多12.98亿点，最多16维</li>
                </ul>
              </div>
            </div>
          </div>
          
          <!-- 性能对比 -->
          <div class="mb-8">
            <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
              <i class="fas fa-tachometer-alt mr-2 text-green-500"></i>
              性能对比
            </h3>
            
            <!-- 性能对比表格 -->
            <details class="technical-details bg-gray-50 rounded-lg p-4 md:p-6 mb-8 mt-6">
              <summary class="cursor-pointer font-semibold text-lg md:text-xl text-gray-800 hover:text-blue-600 transition-colors py-2">
                <i class="fas fa-table mr-2"></i>性能对比：Pkd-tree与基线方法
              </summary>
              
              <div class="mt-6 space-y-6">
                <!-- 原图展示部分 -->
                <div class="original-figure-container">
                  <div class="flex flex-col sm:flex-row sm:items-center justify-between mb-4 gap-2">
                    <h5 class="font-semibold text-gray-700 text-base md:text-lg">
                      <i class="fas fa-image mr-2 text-blue-500"></i>
                      原图 表1: 运行时间对比（秒）
                    </h5>
                    <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded self-start sm:self-auto">论文原表</span>
                  </div>
                  
                  <!-- 原图占位符 -->
                  <div class="image-placeholder bg-gradient-to-br from-gray-100 to-gray-200 p-6 md:p-8 rounded-lg text-center border-2 border-dashed border-gray-300">
                    <img src="./images/table1.png" alt="论文表1: Pkd-tree与基线方法的运行时间对比" class="max-w-full h-auto rounded-lg">
                  </div>
                  
                  <!-- 原图图注 -->
                  <div class="mt-4 text-sm text-gray-600 bg-gray-50 p-3 rounded border">
                    <strong>原图图注:</strong> Pkd-tree和其他基线在10^9个2维点上的运行时间（秒）。"Log-tree": 使用ParGeo库中对数方法的并行kd-tree。"BHL-tree": ParGeo库中的单个并行kd-tree。"CGAL": CGAL库中的kd-tree。"Varden": 来自[38]的偏斜分布。"10-NN": 在10^9个点上的10近邻查询。"Range report": 在10^4个矩形上的正交范围报告查询，输出大小在10^4-10^6之间。实验在96核机器上运行。
                  </div>
                </div>
                
                <!-- 技术解释部分 -->
                <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                  <h5 class="font-semibold text-blue-700 mb-3 flex items-center text-base md:text-lg">
                    <i class="fas fa-info-circle mr-2"></i>技术解释：
                  </h5>
                  <ul class="list-disc list-inside space-y-2 text-sm md:text-base text-gray-700">
                    <li><strong>构建性能:</strong> Pkd-tree在所有测试中都是最快的，比Log-tree快8-12倍，比BHL-tree快8-11倍，比CGAL快39-363倍</li>
                    <li><strong>更新性能:</strong> Pkd-tree在批量更新方面优于所有基线，比Log-tree在插入上快17-40倍，在删除上快3-21倍</li>
                    <li><strong>查询性能:</strong> Pkd-tree在大多数情况下是最快的，在16个实例中的13个中表现最佳</li>
                    <li><strong>内存效率:</strong> Pkd-tree通过不存储边界框优化内存使用，提高缓存利用率</li>
                  </ul>
                </div>
                
                <!-- 设计实现部分 -->
                <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                  <h5 class="font-semibold text-green-700 mb-3 flex items-center text-base md:text-lg">
                    <i class="fas fa-cogs mr-2"></i>设计实现：
                  </h5>
                  <div class="text-sm md:text-base text-gray-700 space-y-3">
                    <div>
                      <strong class="text-green-700">性能优势来源:</strong>
                      <p>Pkd-tree的性能优势主要来自更好的缓存效率和并行扩展性。通过一次构建多级和采样技术，显著减少了内存访问。</p>
                    </div>
                    <div>
                      <strong class="text-green-700">技术选择:</strong>
                      <p>选择不存储边界框，在查询时动态计算子树空间，权衡了较慢的查询性能和更快的构建/更新性能。</p>
                    </div>
                    <div>
                      <strong class="text-green-700">优化策略:</strong>
                      <p>使用叶包装（leaf wrap）和重复点压缩减少内存占用。当子树完全包含在查询框中时，并行输出所有点。</p>
                    </div>
                  </div>
                </div>
                
                <!-- 性能分析部分 -->
                <div class="bg-purple-50 p-4 rounded-lg border border-purple-200">
                  <h5 class="font-semibold text-purple-700 mb-3 flex items-center text-base md:text-lg">
                    <i class="fas fa-chart-line mr-2"></i>性能分析：
                  </h5>
                  <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm md:text-base">
                    <div>
                      <strong class="text-purple-700">缓存效率:</strong>
                      <ul class="list-disc list-inside mt-1 text-gray-700">
                        <li>缓存缺失减少: 6-12倍</li>
                        <li>内存带宽使用: 327-421 GB/s</li>
                        <li>内存使用优化: 不存储边界框</li>
                      </ul>
                    </div>
                    <div>
                      <strong class="text-purple-700">扩展性:</strong>
                      <ul class="list-disc list-inside mt-1 text-gray-700">
                        <li>构建扩展性: 37-56倍加速</li>
                        <li>更新扩展性: 良好并行度</li>
                        <li>查询扩展性: 支持并行查询</li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
            </details>
          </div>
          
          <!-- 技术分析 -->
          <div class="mb-8">
            <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
              <i class="fas fa-microscope mr-2 text-purple-500"></i>
              技术分析
            </h3>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
                <h5 class="font-bold text-gray-800 mb-3 flex items-center">
                  <i class="fas fa-memory mr-2 text-blue-500"></i>
                  缓存效率分析
                </h5>
                <p class="text-sm text-gray-700 mb-3">
                  Pkd-tree在构建过程中比BHL-tree或Log-tree减少6-12倍的缓存缺失，这与Pkd-tree相对于BHL-tree或Log-tree在构建上的加速比接近。
                </p>
                <div class="bg-blue-50 p-3 rounded text-sm">
                  <strong>关键发现:</strong> 在1000M-3D-V构建中报告的缓存缺失表明测试机器超过80%的内存带宽使用。
                </div>
              </div>
              
              <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
                <h5 class="font-bold text-gray-800 mb-3 flex items-center">
                  <i class="fas fa-balance-scale mr-2 text-green-500"></i>
                  平衡参数分析
                </h5>
                <p class="text-sm text-gray-700 mb-3">
                  当α≤0.4时（两个子树大小最多相差9倍），Pkd-tree的查询性能保持相当稳定。选择α=0.3（即20/80）作为Pkd-tree的默认设置。
                </p>
                <div class="bg-green-50 p-3 rounded text-sm">
                  <strong>关键发现:</strong> 查询性能在α的合理大范围内稳定，最坏情况性能直到30/70（α=0.2）都几乎不受影响。
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
      
      <!-- 结论 -->
      <section id="conclusion" class="content-section mobile-optimized mb-12 md:mb-16">
        <h2 class="text-2xl md:text-3xl font-bold text-gray-800 mb-6 md:mb-8 flex items-center">
          <i class="fas fa-flag-checkered mr-3 text-blue-500"></i>
          结论
        </h2>
        
        <div class="prose max-w-none text-gray-700">
          <p class="mb-4">
            作者提出了Pkd-tree，一种并行kd-tree，在树构建和批量更新方面具有work、span和cache复杂度的强大理论保证，并在实践中具有高性能。
          </p>
          
          <div class="bg-gradient-to-r from-green-50 to-blue-50 border-l-4 border-green-500 p-6 rounded-r-lg mb-6">
            <h4 class="font-bold text-green-700 mb-4 flex items-center">
              <i class="fas fa-check-circle mr-2"></i>主要贡献总结
            </h4>
            <ul class="list-disc list-inside space-y-2 text-gray-700">
              <li><strong>采样和多级构建</strong>：同时优化work、span和cache效率</li>
              <li><strong>筛分算法</strong>：通过一轮数据移动高效分区点</li>
              <li><strong>权重平衡方案</strong>：通过可控方式放宽平衡标准</li>
              <li><strong>高效实现</strong>：在构建和更新方面显著优于现有并行kd-tree实现</li>
            </ul>
          </div>
          
          <p class="mb-4">
            通过这种方式，作者的方法以可控的方式放宽了平衡标准，允许在考虑构建、更新和各种查询的整体良好性能。在实验中，Pkd-tree在构建和更新方面显著优于所有现有的并行kd-tree实现，具有竞争性或更好的查询性能。
          </p>
          
          <div class="bg-yellow-50 border-l-4 border-yellow-500 p-4 rounded-r-lg">
            <h5 class="font-bold text-yellow-700 mb-2 flex items-center">
              <i class="fas fa-exclamation-triangle mr-2"></i>局限性
            </h5>
            <ul class="list-disc list-inside text-gray-700">
              <li>在高维查询中，由于不存储边界框，查询性能可能略低于某些基线</li>
              <li>更新成本界限比使用对数方法更高（每点O(log² n)而不是O(log n)）</li>
              <li>对于需要严格平衡的应用，需要设置较小的α值，可能增加更新成本</li>
            </ul>
          </div>
        </div>
      </section>
    </div>
  </div>
  
  <!-- 交互脚本 -->
  <script>
    // 智能导航和交互功能
    document.addEventListener('DOMContentLoaded', function() {
      const navItems = document.querySelectorAll('.nav-item');
      const sections = document.querySelectorAll('section');
      
      function highlightNav() {
        let current = '';
        sections.forEach(section => {
          const sectionTop = section.offsetTop;
          const sectionHeight = section.clientHeight;
          if (window.scrollY >= (sectionTop - 100)) {
            current = section.getAttribute('id');
          }
        });

        navItems.forEach(item => {
          item.classList.remove('active');
          if (item.getAttribute('href') === `#${current}`) {
            item.classList.add('active');
          }
        });
      }

      window.addEventListener('scroll', highlightNav);
      
      // 平滑滚动
      navItems.forEach(item => {
        item.addEventListener('click', function(e) {
          e.preventDefault();
          const targetId = this.getAttribute('href');
          const targetSection = document.querySelector(targetId);
          window.scrollTo({
            top: targetSection.offsetTop - 80,
            behavior: 'smooth'
          });
        });
      });
    });
  </script>
</body>
</html>