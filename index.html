<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>å­¦æœ¯è®ºæ–‡åº“ | Academic Papers</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js"></script>
    
    <link rel="preload" href="./papers_data.json" as="fetch" crossorigin="anonymous" type="application/json">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #60a5fa, #a855f7, #ec4899);
            min-height: 100vh;
        }
        
        .glass-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .paper-item {
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 0.75rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .paper-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
        
        .nav-item {
            transition: all 0.2s ease;
        }
        
        .nav-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .nav-item.active {
            background: rgba(255, 255, 255, 0.3);
            font-weight: 600;
        }
        
        #backToTop {
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            position: fixed;
            bottom: 110px;
            right: 20px;
            z-index: 100;
        }
        
        #backToTop:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.1);
        }
        
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .line-clamp-3 {
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .pagination-btn {
            transition: all 0.2s ease;
        }
        
        .pagination-btn:hover:not(.disabled) {
            background: rgba(255, 255, 255, 0.9);
            transform: translateY(-1px);
        }
        
        .pagination-btn.active {
            background: rgba(59, 130, 246, 0.9);
            color: white;
        }

        .update-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #10b981;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        
        /* åº•éƒ¨æ ‡è¯†å®¹å™¨ */
        .footer-notices {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
        }

        /* AIæ•°æ®æ ‡è¯† */
        .ai-notice {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 6px;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* è”ç³»æ ‡è¯† */
        .contact-notice {
            background: rgba(59, 130, 246, 0.9);
            color: white;
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 6px;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .contact-notice a {
            color: white;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .contact-notice:hover {
            background: rgba(59, 130, 246, 1);
        }

        .ai-notice:hover, .contact-notice:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        /* æœç´¢é«˜äº®æ ·å¼ */
        .highlight {
            background-color: #fef08a;
            padding: 0.1em 0.2em;
            border-radius: 0.25em;
            font-weight: 600;
        }
        
        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 768px) {
            .nav-container {
                overflow-x: auto;
                white-space: nowrap;
                -webkit-overflow-scrolling: touch;
                padding-bottom: 0.5rem;
            }
            
            .nav-item {
                display: inline-block;
            }
            
            .search-box {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .paper-item {
                padding: 1rem !important;
            }
            
            .paper-info {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .paper-meta {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            
            .footer-notices {
                bottom: 10px;
                right: 10px;
            }
            
            #backToTop {
                bottom: 110px;
                right: 10px;
            }
            
            .ai-notice, .contact-notice {
                font-size: 11px;
                padding: 6px 10px;
            }
        }
    </style>
</head>
<body class="text-gray-800">
    <nav class="glass-card mx-4 mt-4 md:mx-8 lg:mx-16 sticky top-4 z-10">
        <div class="px-4 py-3">
            <div class="flex flex-col md:flex-row md:justify-between md:items-center">
                <div class="flex items-center justify-between mb-4 md:mb-0">
                    <div class="flex items-center">
                        <div class="bg-gradient-to-r from-blue-500 to-purple-600 p-2 rounded-lg mr-3">
                            <i class="fas fa-graduation-cap text-white text-xl"></i>
                        </div>
                        <h1 class="text-xl font-bold">å­¦æœ¯è®ºæ–‡åº“</h1>
                        <span class="ml-2 text-sm bg-gradient-to-r from-blue-500 to-purple-600 text-white px-2 py-1 rounded-full">Beta</span>
                    </div>
                    <div class="md:hidden text-sm bg-white/80 px-2 py-1 rounded-full">
                        <span id="mobilePaperCount">åŠ è½½ä¸­...</span> ç¯‡è®ºæ–‡
                    </div>
                </div>
                
                <div class="hidden md:flex items-center text-sm bg-white/80 px-3 py-1 rounded-full mt-4 md:mt-0">
                    <i class="fas fa-file-alt text-blue-500 mr-2"></i>
                    å…± <span id="paperCount">åŠ è½½ä¸­...</span> ç¯‡è®ºæ–‡
                    <span id="cacheStatus" class="ml-2 text-xs bg-green-100 text-green-800 px-2 py-0.5 rounded-full hidden">
                        <i class="fas fa-database mr-1"></i>å·²ç¼“å­˜
                    </span>
                </div>
            </div>
        </div>
    </nav>

    <div class="px-4 md:px-8 lg:px-16 py-8">
        <div class="glass-card p-6 mb-8">
            <div class="text-center mb-6">
                <h2 class="text-3xl font-bold mb-2 bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">æ¢ç´¢å­¦æœ¯è®ºæ–‡</h2>
                <p class="text-gray-600 max-w-2xl mx-auto">é€‰æ‹©æœç´¢èŒƒå›´ï¼Œç²¾ç¡®æŸ¥æ‰¾æˆ–è¿›è¡Œæ¨¡ç³Šæœç´¢</p>
            </div>
            
            <div class="max-w-3xl mx-auto">
                <div class="flex search-box space-x-2">
                    <select id="searchFieldSelect" class="flex-shrink-0 px-4 py-4 border border-gray-200 rounded-xl shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-base bg-white/80">
                        <option value="fuzzy">æ¨¡ç³Šæœç´¢ (å…¨éƒ¨)</option>
                        <option value="conference">ä¼šè®® (ç²¾ç¡®)</option>
                        <option value="year">å¹´ä»½ (ç²¾ç¡®)</option>
                        <option value="title">æ ‡é¢˜ (æ¨¡ç³Š)</option>
                        <option value="abstract">æ‘˜è¦ (æ¨¡ç³Š)</option>
                    </select>

                    <div class="relative flex-grow">
                        <input type="text" id="searchInput" placeholder="è¯·è¾“å…¥å…³é”®è¯è¿›è¡Œæœç´¢..." class="w-full px-6 py-4 border border-gray-200 rounded-xl shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-lg bg-white/80">
                        <i class="fas fa-search absolute right-4 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
                    </div>
                </div>
                
                <div class="mt-2 text-sm text-gray-500 flex justify-between">
                    <span id="searchTip">å½“å‰æ¨¡å¼ï¼šæ¨¡ç³Šæœç´¢ï¼ˆæ ‡é¢˜/æ‘˜è¦/ä¼šè®®/å¹´ä»½åŠ æƒï¼‰</span>
                    <span id="searchStats" class="text-blue-600 font-medium"></span>
                </div>
            </div>
        </div>

        <div id="loading" class="glass-card p-12 text-center">
            <div class="flex flex-col items-center">
                <i class="fas fa-spinner fa-spin text-3xl text-blue-600 mb-4"></i>
                <p class="text-gray-600 mb-2">æ­£åœ¨åŠ è½½è®ºæ–‡æ•°æ®...</p>
                <p id="loadingStatus" class="text-sm text-gray-500">åˆå§‹åŒ–ç•Œé¢...</p>
            </div>
        </div>
        
        <div id="noResults" class="glass-card p-12 text-center hidden">
            <i class="fas fa-search text-4xl text-gray-400 mb-4"></i>
            <h3 class="text-xl font-semibold text-gray-700 mb-2">æœªæ‰¾åˆ°ç›¸å…³è®ºæ–‡</h3>
            <p class="text-gray-500 mb-4">å°è¯•ä½¿ç”¨ä¸åŒçš„å…³é”®è¯æˆ–ç­›é€‰æ¡ä»¶</p>
            <button id="resetSearch" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                é‡ç½®æœç´¢
            </button>
        </div>
        
        <div id="papersContainer" class="hidden">
            <div class="flex justify-between items-center mb-6">
                <div class="text-sm text-gray-600">
                    æ˜¾ç¤º <span id="currentRange">0-0</span> æ¡ï¼Œå…± <span id="totalPapers">0</span> ç¯‡è®ºæ–‡
                    <span id="dataSource" class="ml-2 text-xs bg-blue-100 text-blue-800 px-2 py-0.5 rounded-full">æœ¬åœ°ç¼“å­˜</span>
                </div>
                <div class="flex items-center space-x-2 text-sm text-gray-600">
                    <span>æ’åºï¼š</span>
                    <select id="sortSelect" class="bg-white/80 border border-gray-200 rounded-lg px-3 py-1 focus:ring-2 focus:ring-blue-500">
                        <option value="year-desc">æœ€æ–°å¹´ä»½</option>
                        <option value="year-asc">æœ€æ—©å¹´ä»½</option>
                        <option value="title-asc">æ ‡é¢˜ A-Z</option>
                        <option value="title-desc">æ ‡é¢˜ Z-A</option>
                    </select>
                </div>
            </div>
            
            <div id="papersList" class="space-y-4 mb-8">
                </div>
            
            <div id="paginationContainer" class="flex justify-center items-center space-x-2">
                </div>
        </div>
    </div>

    <button id="backToTop" class="fixed text-blue-600 p-4 rounded-full shadow-lg opacity-0 z-10">
        <i class="fas fa-arrow-up text-xl"></i>
    </button>

    <div class="footer-notices">
        <div class="ai-notice">
            <i class="fas fa-robot"></i>AIç”Ÿæˆæ•°æ®
        </div>
        <div class="contact-notice">
            <a href="mailto:me@hoooo.org">
                <i class="fas fa-envelope"></i>é—®é¢˜åé¦ˆ
            </a>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let allPapers = [];
        let filteredPapers = [];
        let currentPage = 1;
        const papersPerPage = 10;
        let currentSort = 'year-desc';
        let paperDatabase = null;
        let autoUpdater = null;
        
        // Fuse.js å®ä¾‹
        let fuseSearch = null;
        // æ–°å¢ï¼šå½“å‰é€‰æ‹©çš„æœç´¢å­—æ®µ
        let currentSearchField = 'fuzzy'; 

        // IndexedDB æ•°æ®åº“ç±»
        class PaperDatabase {
            constructor() {
                this.dbName = 'AcademicPapersDB';
                this.version = 4;
            }
            
            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('papers')) {
                            const store = db.createObjectStore('papers', { keyPath: 'id' });
                            store.createIndex('title', 'title', { multiEntry: false });
                            store.createIndex('authors', 'authors', { multiEntry: true });
                            store.createIndex('year', 'year', { multiEntry: false });
                            store.createIndex('category', 'category', { multiEntry: false });
                            store.createIndex('conference', 'conference', { multiEntry: false });
                        }
                        
                        if (!db.objectStoreNames.contains('metadata')) {
                            const metadataStore = db.createObjectStore('metadata', { keyPath: 'key' });
                        }
                    };
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve(this.db);
                    };
                    
                    request.onerror = (event) => reject(event.target.error);
                });
            }

            async getMetadata(key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['metadata'], 'readonly');
                    const store = transaction.objectStore('metadata');
                    const request = store.get(key);
                    
                    request.onsuccess = () => resolve(request.result ? request.result.value : null);
                    request.onerror = () => reject(request.error);
                });
            }

            async setMetadata(key, value) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['metadata'], 'readwrite');
                    const store = transaction.objectStore('metadata');
                    const request = store.put({ key, value });
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async needsUpdate(papers, fileTimestamp) {
                const newHash = await this.calculateDataHash(papers);
                const oldHash = await this.getMetadata('dataHash');
                const oldTimestamp = await this.getMetadata('fileTimestamp');
                
                console.log('ğŸ” æ£€æŸ¥æ•°æ®æ›´æ–°:', {
                    æ–°æ—¶é—´æˆ³: fileTimestamp,
                    æ—§æ—¶é—´æˆ³: oldTimestamp,
                    æ–°å“ˆå¸Œ: newHash?.substring(0, 8) + '...',
                    æ—§å“ˆå¸Œ: oldHash?.substring(0, 8) + '...'
                });
                
                return newHash !== oldHash || fileTimestamp !== oldTimestamp;
            }

            async calculateDataHash(papers) {
                const dataStr = JSON.stringify(papers);
                const encoder = new TextEncoder();
                const data = encoder.encode(dataStr);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            async getAllPapers() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['papers'], 'readonly');
                    const store = transaction.objectStore('papers');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            }

            async storePapers(papers, fileTimestamp) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['papers', 'metadata'], 'readwrite');
                    const paperStore = transaction.objectStore('papers');
                    const metadataStore = transaction.objectStore('metadata');
                    
                    const clearRequest = paperStore.clear();
                    
                    clearRequest.onsuccess = () => {
                        papers.forEach(paper => {
                            paperStore.add(paper);
                        });
                        
                        this.calculateDataHash(papers).then(hash => {
                            metadataStore.put({ key: 'dataHash', value: hash });
                            metadataStore.put({ 
                                key: 'lastUpdated', 
                                value: new Date().toISOString() 
                            });
                            metadataStore.put({ 
                                key: 'totalCount', 
                                value: papers.length 
                            });
                            if (fileTimestamp) {
                                metadataStore.put({ 
                                    key: 'fileTimestamp', 
                                    value: fileTimestamp 
                                });
                            }
                        });
                        
                        resolve();
                    };
                    
                    clearRequest.onerror = () => reject(clearRequest.error);
                });
            }

            async getStats() {
                const lastUpdated = await this.getMetadata('lastUpdated');
                const totalCount = await this.getMetadata('totalCount');
                const fileTimestamp = await this.getMetadata('fileTimestamp');
                
                return {
                    lastUpdated,
                    totalCount: totalCount || 0,
                    fileTimestamp: fileTimestamp || null,
                    isCached: !!lastUpdated
                };
            }
        }

        // åˆå§‹åŒ– Fuse.js æœç´¢ç´¢å¼• (è®¾ç½®é»˜è®¤å¤šå­—æ®µåŠ æƒ)
        function initSearchIndex(papers) {
            console.log('ğŸ” åˆå§‹åŒ– Fuse.js æœç´¢ç´¢å¼•...');
            
            // é…ç½® Fuse.js é€‰é¡¹
            const options = {
                keys: [
                    { name: 'title', weight: 3 },       // æ ‡é¢˜æƒé‡æœ€é«˜
                    { name: 'abstract', weight: 2 },    // æ‘˜è¦
                    { name: 'conference', weight: 2 },  // ä¼šè®®
                    { name: 'year', weight: 2 },        // å¹´ä»½
                    { name: 'authors', weight: 1 },
                    { name: 'keywords', weight: 1 },
                    { name: 'category', weight: 1 }
                ],
                includeScore: true,
                includeMatches: true, 
                ignoreLocation: true, 
                threshold: 0.3, // æ¨¡ç³ŠåŒ¹é…é˜ˆå€¼ (ç”¨äº 'fuzzy' æ¨¡å¼)
                isCaseSensitive: false, 
            };

            // åˆ›å»º Fuse å®ä¾‹
            fuseSearch = new Fuse(papers, options);

            console.log('âœ… Fuse.js æœç´¢ç´¢å¼•åˆå§‹åŒ–å®Œæˆï¼Œå…±ç´¢å¼•', papers.length, 'ç¯‡è®ºæ–‡');
        }

        // é«˜æ€§èƒ½æœç´¢å‡½æ•°
        function performSearch(query) {
            const startTime = performance.now();
            
            if (!query.trim()) {
                filteredPapers = [...allPapers];
                document.getElementById('searchStats').textContent = '';
            } else {
                try {
                    const trimmedQuery = query.toString().trim();

                    if (currentSearchField === 'year') {
                        // **å¹´ä»½æ¨¡å¼ï¼šä¸¥æ ¼çš„ç²¾ç¡®åŒ¹é…ï¼Œè§£å†³ 2023 åŒ¹é…åˆ° 2025 çš„é—®é¢˜**
                        filteredPapers = allPapers.filter(paper => 
                            paper.year && paper.year.toString() === trimmedQuery
                        );
                    } else {
                        // å…¶ä»–æ¨¡å¼ï¼šä½¿ç”¨ Fuse.js
                        let searchOptions = {
                            limit: 1000, 
                            // ä¿æŒ includeScore å’Œ includeMatches
                        };
                        
                        if (currentSearchField === 'fuzzy') {
                            // æ¨¡ç³Šæ¨¡å¼ï¼šä½¿ç”¨å…¨å±€è®¾ç½®ï¼ˆå¤šå­—æ®µåŠ æƒï¼Œthreshold: 0.3ï¼‰
                            // é»˜è®¤æƒ…å†µä¸‹ Fuse.js search() ä¼šä½¿ç”¨åˆå§‹åŒ–æ—¶çš„é…ç½®
                        } else {
                            // å•å­—æ®µæ¨¡å¼ï¼šæœç´¢ç‰¹å®šå­—æ®µ (conference, title, abstract)
                            searchOptions.keys = [currentSearchField];
                            searchOptions.threshold = 0.2; // ç•¥å¾®æ”¶ç´§é˜ˆå€¼ï¼Œæå‡å•å­—æ®µç²¾å‡†åº¦
                        }

                        const searchResults = fuseSearch.search(trimmedQuery, searchOptions);
                        
                        // Fuse.js è¿”å› {item: paperData, score: ...} æ•°ç»„
                        filteredPapers = searchResults.map(result => result.item);
                    }
                    
                    const endTime = performance.now();
                    const searchTime = (endTime - startTime).toFixed(2);
                    
                    document.getElementById('searchStats').textContent = 
                        `æ‰¾åˆ° ${filteredPapers.length} ç¯‡è®ºæ–‡ (${searchTime}ms)`;
                    
                    console.log(`ğŸ” æœç´¢ "${trimmedQuery}" (å­—æ®µ: ${currentSearchField})ï¼šæ‰¾åˆ° ${filteredPapers.length} ç¯‡è®ºæ–‡ï¼Œè€—æ—¶ ${searchTime}ms`);
                    
                } catch (error) {
                    console.error('æœç´¢é”™è¯¯:', error);
                    // é™çº§åˆ°åŸºç¡€æœç´¢ (ä¿ç•™ï¼Œä½œä¸º Fuse.js å½»åº•å¤±è´¥çš„å¤‡ç”¨)
                    fallbackSearch(query);
                }
            }
            
            currentPage = 1;
            applySorting();
            setupPagination();
        }

        // é™çº§æœç´¢æ–¹æ¡ˆ 
        function fallbackSearch(query) {
            console.warn('æœç´¢å¤±è´¥ï¼Œä½¿ç”¨é™çº§æœç´¢æ–¹æ¡ˆ');
            const lowerQuery = query.toLowerCase();
            filteredPapers = allPapers.filter(paper => 
                (paper.title && paper.title.toLowerCase().includes(lowerQuery)) ||
                (paper.authors && Array.isArray(paper.authors) && paper.authors.some(author => author.toLowerCase().includes(lowerQuery))) ||
                (paper.keywords && Array.isArray(paper.keywords) && paper.keywords.some(keyword => keyword.toLowerCase().includes(lowerQuery))) ||
                (paper.conference && paper.conference.toLowerCase().includes(lowerQuery)) ||
                (paper.abstract && paper.abstract.toLowerCase().includes(lowerQuery)) ||
                (paper.category && paper.category.toLowerCase().includes(lowerQuery)) ||
                (paper.year && paper.year.toString().includes(lowerQuery))
            );
        }

        // é«˜äº®åŒ¹é…æ–‡æœ¬ (ä¿ç•™)
        function highlightMatch(text, query) {
            if (!text || !query) return text || '';
            
            try {
                // ä½¿ç”¨ 'gi' æ ‡å¿—è¿›è¡Œå…¨å±€ã€å¤§å°å†™ä¸æ•æ„Ÿçš„é«˜äº®
                const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(`(${escapedQuery})`, 'gi');
                return text.toString().replace(regex, '<span class="highlight">$1</span>');
            } catch (error) {
                return text;
            }
        }

        // --- å…¶ä»–è¾…åŠ©å‡½æ•° (ä¿æŒä¸å˜) ---

        async function fetchLatestPapersFile() {
            // ... (ä¿æŒä¸å˜)
        }

        class AutoUpdater {
            // ... (ä¿æŒä¸å˜)
            async checkForUpdates() {
                // ... (ä¿æŒä¸å˜)
                // ç¡®ä¿æ•°æ®æ›´æ–°åé‡æ–°åˆå§‹åŒ– Fuse.js
                // initSearchIndex(allPapers); 
                // ... (å·²åœ¨åŸä»£ç ä¸­å®ç°)
            }
        }

        function fixPaperPaths(paper) {
            // ... (ä¿æŒä¸å˜)
        }

        function updateLoadingStatus(message) {
            // ... (ä¿æŒä¸å˜)
        }

        function showCacheStatus() {
            // ... (ä¿æŒä¸å˜)
        }

        function showNetworkStatus() {
            // ... (ä¿æŒä¸å˜)
        }

        // æ¸²æŸ“è®ºæ–‡åˆ—è¡¨ (ä¿æŒä¸å˜)
        function renderPapers() {
            // ... (ä¿æŒä¸å˜)
        }

        function getCategoryColor(category) {
            // ... (ä¿æŒä¸å˜)
        }

        // ä¸»è¦åŠŸèƒ½å‡½æ•° (ä¿æŒä¸å˜)
        async function loadPapers() {
            // ... (ä¿æŒä¸å˜)
        }

        function updatePaperCount() {
            // ... (ä¿æŒä¸å˜)
        }

        function showError() {
            // ... (ä¿æŒä¸å˜)
        }

        function applySorting() {
            // ... (ä¿æŒä¸å˜)
        }

        function setupPagination() {
            // ... (ä¿æŒä¸å˜)
        }

        function setupBackToTop() {
            // ... (ä¿æŒä¸å˜)
        }

        // é˜²æŠ–æœç´¢å‡½æ•° (ä¿æŒä¸å˜)
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // **æ–°å¢ï¼šæ ¹æ®é€‰æ‹©å™¨æ›´æ–°æœç´¢æç¤º**
        function updateSearchTip() {
            const select = document.getElementById('searchFieldSelect');
            const tipElement = document.getElementById('searchTip');
            const selectedText = select.options[select.selectedIndex].text;
            
            let tip = `å½“å‰æ¨¡å¼ï¼š${selectedText}`;

            if (currentSearchField === 'fuzzy') {
                tip = 'å½“å‰æ¨¡å¼ï¼šæ¨¡ç³Šæœç´¢ï¼ˆæ ‡é¢˜/æ‘˜è¦/ä¼šè®®/å¹´ä»½åŠ æƒï¼‰';
            } else if (currentSearchField === 'year') {
                tip = 'å½“å‰æ¨¡å¼ï¼šå¹´ä»½ï¼ˆç²¾ç¡®åŒ¹é…ï¼Œä¾‹å¦‚ 2023ï¼‰';
            } else if (currentSearchField === 'conference') {
                tip = 'å½“å‰æ¨¡å¼ï¼šä¼šè®®ï¼ˆå•å­—æ®µæ¨¡ç³ŠåŒ¹é…ï¼Œä¾‹å¦‚ FASTï¼‰';
            } else if (currentSearchField === 'title') {
                tip = 'å½“å‰æ¨¡å¼ï¼šæ ‡é¢˜ï¼ˆå•å­—æ®µæ¨¡ç³ŠåŒ¹é…ï¼‰';
            } else if (currentSearchField === 'abstract') {
                tip = 'å½“å‰æ¨¡å¼ï¼šæ‘˜è¦ï¼ˆå•å­—æ®µæ¨¡ç³ŠåŒ¹é…ï¼‰';
            }
            tipElement.textContent = tip;
        }


        // äº‹ä»¶ç›‘å¬
        document.getElementById('searchInput').addEventListener('input', debounce((e) => {
            performSearch(e.target.value);
        }, 300));
        
        // **æ–°å¢ï¼šæœç´¢å­—æ®µé€‰æ‹©å™¨ç›‘å¬**
        document.getElementById('searchFieldSelect').addEventListener('change', (e) => {
            currentSearchField = e.target.value;
            updateSearchTip();
            // åˆ‡æ¢æ¨¡å¼åï¼Œå¦‚æœè¾“å…¥æ¡†æœ‰å†…å®¹ï¼Œåˆ™è‡ªåŠ¨é‡æ–°æœç´¢
            const query = document.getElementById('searchInput').value.trim();
            if (query) {
                performSearch(query);
            }
        });

        document.getElementById('resetSearch').addEventListener('click', () => {
            document.getElementById('searchInput').value = '';
            document.getElementById('searchStats').textContent = '';
            filteredPapers = [...allPapers];
            currentPage = 1;
            applySorting();
            setupPagination();
        });

        document.getElementById('sortSelect').addEventListener('change', (e) => {
            currentSort = e.target.value;
            applySorting();
            setupPagination();
        });

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            loadPapers();
            setupBackToTop();
            updateSearchTip(); // åˆå§‹åŒ–æç¤º
        });
    </script>
</body>
</html>